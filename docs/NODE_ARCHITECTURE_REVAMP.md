# Node Architecture Revamp

## Overview

This document describes a fundamental redesign of how Draehi models and stores Logseq data. The previous approach treated pages and blocks as separate entities with artificial hierarchy encoding. The new approach recognizes that **everything is a node**, with hierarchy represented through natural graph relationships in SurrealDB.

## The Problem with the Old Model

### Previous Understanding
- **Pages** = top-level markdown files with special treatment
- **Blocks** = content fragments within pages
- **Hierarchy** = encoded via `page_name` field and artificial `order` value
- **Assumption** = pages are fundamentally different from blocks

### Why This Failed
1. **Loss of Logseq Fidelity**: Logseq's tab indentation and nesting structure was flattened
2. **Artificial Encoding**: The `order` field and `page_name` duplication created a pseudo-hierarchy instead of using natural relationships
3. **Missing Features**: Block embeds `((uuid))`, nested block references, and proper hierarchy navigation were impossible
4. **Scalability**: Flat structures don't scale well to deeply nested block hierarchies (Logseq supports 50+ levels)
5. **Query Complexity**: Finding siblings, ancestors, descendants required manual post-processing

## The Correct Model: Everything is a Node

### Core Principle
In Logseq and in Draehi:
- **A node** is the atomic unit of content
- **Pages** are nodes with `parent = null` (top-level)
- **Blocks** are nodes with `parent = some_node_id` (nested)
- **Hierarchy** emerges from parent-child relationships

### Example Structure

```
Logseq Markdown File: "Advanced Queries.md"
├── # Advanced Queries (heading/page node)
│   ├── Query basics (block node, parent=page)
│   │   ├── Simple queries (sub-block, parent=block)
│   │   └── Complex queries (sub-block, parent=block)
│   └── Advanced techniques (block node, parent=page)
│       ├── Filtering (sub-block, parent=block)
│       └── Sorting (sub-block, parent=block)

In SurrealDB nodes table:
┌─ Node: id=uuid1, parent=null, title="Advanced Queries", slug="advanced-queries"
│  ├─ Node: id=uuid2, parent=uuid1, title="Query basics"
│  │  ├─ Node: id=uuid3, parent=uuid2, title="Simple queries"
│  │  └─ Node: id=uuid4, parent=uuid2, title="Complex queries"
│  └─ Node: id=uuid5, parent=uuid1, title="Advanced techniques"
│     ├─ Node: id=uuid6, parent=uuid5, title="Filtering"
│     └─ Node: id=uuid7, parent=uuid5, title="Sorting"
```

## SurrealDB Schema

### nodes Table

```sql
DEFINE TABLE IF NOT EXISTS nodes SCHEMAFULL;

-- Primary identifier (UUID generated by Logseq or hashed from content)
DEFINE FIELD IF NOT EXISTS id ON nodes TYPE string;

-- Workspace this node belongs to
DEFINE FIELD IF NOT EXISTS workspace ON nodes TYPE record<workspaces>;

-- Hierarchy: parent node (null for pages, FK for blocks)
DEFINE FIELD IF NOT EXISTS parent ON nodes TYPE option<record<nodes>>;

-- Ordering: position among siblings with same parent
-- Used for rendering blocks in correct order
DEFINE FIELD IF NOT EXISTS order ON nodes TYPE int DEFAULT 0;

-- Content identifier
DEFINE FIELD IF NOT EXISTS page_name ON nodes TYPE string;
DEFINE FIELD IF NOT EXISTS slug ON nodes TYPE string;

-- Display title (pages only, optional for blocks)
DEFINE FIELD IF NOT EXISTS title ON nodes TYPE option<string>;

-- Node metadata: tags, properties, references, etc.
DEFINE FIELD IF NOT EXISTS metadata ON nodes TYPE option<object>;

-- Timestamps
DEFINE FIELD IF NOT EXISTS created_at ON nodes TYPE datetime DEFAULT time::now();
DEFINE FIELD IF NOT EXISTS updated_at ON nodes TYPE datetime DEFAULT time::now();

-- Indexes for performance
DEFINE INDEX IF NOT EXISTS nodes_workspace ON nodes FIELDS workspace;
DEFINE INDEX IF NOT EXISTS nodes_workspace_slug ON nodes FIELDS workspace, slug;
DEFINE INDEX IF NOT EXISTS nodes_parent_order ON nodes FIELDS parent, order;
```

### Why `page_name` Stays

In Logseq markdown:
```markdown
# Advanced Queries
- Regular block
  - Nested block
    - Deeper block
```

All these blocks belong to the "Advanced Queries" page. The `page_name` field acts as a **reverse index** - given a block deep in the tree, you can instantly know which page it belongs to without traversing ancestors.

## KeyDB Storage

### HTML Content Layer

KeyDB stores rendered HTML with a simple key structure:

```
Key: workspace:{workspace_id}:block:{node_uuid}
Value: <html>content here</html>
```

### Why Separate from SurrealDB

1. **Size**: HTML can be megabytes per node; database storage is expensive
2. **Speed**: Redis/KeyDB is 10-100x faster for simple key lookups
3. **Separation of Concerns**: Metadata in SurrealDB, content in KeyDB
4. **Flexibility**: Can invalidate/regenerate HTML without touching database
5. **Caching**: Ephemeral nature suits content that regenerates on every deployment

## Data Flow: From Logseq to Display

### 1. Ingestion Phase

```
Markdown File (Logseq export)
    ↓
Parse Block Structure
    ├─ Identify hierarchy via indentation/nesting
    ├─ Assign UUIDs (from Logseq's id:: property or hash)
    └─ Create node with parent chain: null → parent_id → grandparent_id

    ↓
Render to HTML
    ├─ Convert markdown → HTML (marked library)
    ├─ Process [[links]] → navigation links
    ├─ Process ((embeds)) → block references
    └─ Process custom Logseq syntax

    ↓
Store in SurrealDB
    ├─ Create node records with parent relationships
    ├─ Set order based on appearance order
    └─ Store metadata (tags, properties, references)

    ↓
Store in KeyDB
    └─ workspace:{id}:block:{uuid} → HTML content
```

### 2. Query Phase (User visits URL)

```
Given: /workspace-slug/advanced-queries

Query SurrealDB:
  1. Find page node: WHERE slug='advanced-queries' AND parent IS NONE
  2. Load page metadata (title, tags, properties)
  3. Get full tree: Recursively fetch all children with their children
     - Query: SELECT * FROM nodes WHERE parent=$node_id ORDER BY order
     - Recurse on each child
  4. Result: Tree structure with all nodes

  ↓

Fetch HTML from KeyDB:
  For each node in tree:
    - Get HTML: KeyDB.get("workspace:{id}:block:{uuid}")
    - If null: node has no rendered content (skip or show placeholder)

  ↓

Build Response:
  ├─ Page metadata + HTML structure
  ├─ Generate TOC from tree
  ├─ Render blocks in tree order with proper indentation
  └─ Include navigation breadcrumbs and backlinks
```

### 3. Render Phase (Frontend)

```typescript
// Tree structure from query
{
  node: { id, title, slug, parent: null },
  children: [
    {
      node: { id, title, parent: uuid },
      html: "<p>Block content</p>",
      children: [
        {
          node: { id, title, parent: uuid },
          html: "<p>Nested block</p>",
          children: []
        }
      ]
    }
  ]
}

// Render recursively
renderTree(node, depth=0):
  - Fetch HTML from node.html
  - Render with indentation based on depth
  - Recursively render children
  - Build TOC entries from tree structure
```

## Key Advantages of New Model

| Aspect | Old Model | New Model |
|--------|-----------|-----------|
| **Hierarchy** | Artificial `order` + `page_name` | Natural parent FK relationships |
| **Depth** | Limited, awkward | Unlimited nesting |
| **Queries** | Manual tree building | Native SurrealDB graph queries |
| **Features** | Block embeds impossible | Block embeds work naturally |
| **Data Integrity** | Duplication (page_name repeated) | Single source of truth |
| **Performance** | Flat scans | Index-based lookups |
| **Logseq Fidelity** | Lost structure | Preserves exact hierarchy |

## Migration Path

### Phase 1: Schema Update
- [x] Make `title` optional in nodes table
- [ ] Keep `parent` as FK to nodes
- [ ] Verify indexes are present

### Phase 2: Ingestion Rewrite
- [ ] Rewrite `modules/content/actions.ts:ingestLogseqGraph()`
- [ ] Parse markdown with proper hierarchy tracking
- [ ] Create nodes recursively with parent chain
- [ ] Store HTML in KeyDB with UUID key

### Phase 3: Query Layer Update
- [ ] Rewrite `modules/content/queries.ts`
- [ ] Implement recursive tree building
- [ ] Add tree traversal utilities

### Phase 4: Rendering Update
- [ ] Update page component to render tree structure
- [ ] Update BlockTree component for recursive rendering
- [ ] Implement TOC generation from tree

### Phase 5: Testing & Validation
- [ ] Test with sample Logseq graphs
- [ ] Verify all blocks render correctly
- [ ] Check nested block handling (30+ levels)
- [ ] Validate [[link]] and ((embed)) processing

## Implementation Details

### Node Creation in Ingestion

```typescript
// When parsing markdown block with indentation level N
async function createNodeWithParents(
  workspaceId: string,
  block: LogseqBlock,
  parentUuid: string | null,
  order: number
): Promise<string> {
  const nodeUuid = block.uuid || hashContent(block);

  await createWithId(`nodes:${nodeUuid}`, {
    workspace: workspaceId,
    parent: parentUuid ? `nodes:${parentUuid}` : null,
    page_name: currentPageName,
    slug: currentPageSlug,
    title: block.title || null, // Only for top-level blocks
    order: order,
    metadata: {
      tags: block.tags,
      properties: block.properties,
      references: extractReferences(block.content),
    },
  });

  return nodeUuid;
}
```

### Tree Building Query

```typescript
async function getNodeTree(nodeId: string): Promise<TreeNode> {
  const node = await selectOne(nodeId);

  const children = await query(
    "SELECT * FROM nodes WHERE parent = $parent ORDER BY order",
    { parent: nodeId }
  );

  return {
    node: normalizeNode(node),
    children: await Promise.all(
      children.map(child => getNodeTree(child.id))
    )
  };
}
```

## Related Files

- [modules/content/schema.ts](../modules/content/schema.ts) - Node interface definitions
- [modules/content/actions.ts](../modules/content/actions.ts) - Ingestion logic (TO BE REWRITTEN)
- [modules/content/queries.ts](../modules/content/queries.ts) - Query layer (TO BE REWRITTEN)
- [lib/keydb.ts](../lib/keydb.ts) - KeyDB operations
- [scripts/init-surreal-schema.ts](../scripts/init-surreal-schema.ts) - SurrealDB schema

## References

- [ROADMAP.md](./ROADMAP.md) - Development phases
- [DATABASE.md](./DATABASE.md) - Database architecture
- [CLAUDE.md](../CLAUDE.md) - Project guidelines
