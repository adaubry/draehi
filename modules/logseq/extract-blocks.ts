import { parse } from "node-html-parser";
import type { LogseqBlock } from "./markdown-parser";
import fs from "fs/promises";
import path from "path";

export type BlockHTML = {
  uuid: string | null;
  html: string;
  order: number;
};

/**
 * Extract individual block HTML from Rust tool's combined HTML output
 *
 * Strategy:
 * 1. Parse the full page HTML generated by export-logseq-notes
 * 2. Match blocks from markdown parser to HTML elements
 * 3. Extract and clean HTML for each block
 *
 * Challenges:
 * - Rust tool only adds `id` attribute to top-level blocks
 * - Nested blocks have id:: rendered as inline text
 * - HTML structure is flattened (no nested <ul>)
 */
export async function extractBlocksFromHTML(
  htmlFilePath: string,
  blocks: LogseqBlock[]
): Promise<BlockHTML[]> {
  // Read the HTML file generated by Rust tool
  const htmlContent = await fs.readFile(htmlFilePath, "utf-8");
  const root = parse(htmlContent);

  const blockHTMLMap = new Map<string, string>();

  // Find all <li> elements (blocks are rendered as list items)
  const listItems = root.querySelectorAll("li");

  // First pass: Extract blocks with id attributes (top-level blocks)
  for (const li of listItems) {
    const id = li.getAttribute("id");
    if (id) {
      // Get the innerHTML and clean it up
      const html = li.innerHTML.trim();
      blockHTMLMap.set(id, html);
    }
  }

  // Second pass: Match remaining blocks by content similarity
  // This handles nested blocks where id:: is rendered as text
  const unmappedBlocks = blocks.filter(b => b.uuid && !blockHTMLMap.has(b.uuid));
  const unmappedListItems = listItems.filter(li => !li.getAttribute("id"));

  for (const block of unmappedBlocks) {
    if (!block.uuid) continue;

    // Try to find matching <li> by checking if content starts with block text
    const blockContentStart = block.content.substring(0, 50).toLowerCase();

    for (let i = 0; i < unmappedListItems.length; i++) {
      const li = unmappedListItems[i];
      const liText = li.text.toLowerCase();

      // Check if this li contains the block's content
      if (liText.includes(blockContentStart)) {
        let html = li.innerHTML.trim();

        // Clean up the id:: property that was rendered as text
        // Pattern: <br /><span><span>id:</span> <span>UUID</span></span>
        html = html.replace(
          /<br\s*\/?>\s*<span>\s*<span>id:<\/span>\s*<span>[a-f0-9-]+<\/span>\s*<\/span>/gi,
          ""
        );

        blockHTMLMap.set(block.uuid, html.trim());

        // Remove from unmapped list to avoid duplicate matching
        unmappedListItems.splice(i, 1);
        break;
      }
    }
  }

  // Build result array preserving order from blocks array
  const result: BlockHTML[] = [];

  for (const block of blocks) {
    const html = block.uuid ? blockHTMLMap.get(block.uuid) : null;

    result.push({
      uuid: block.uuid,
      html: html || `<p>${escapeHtml(block.content)}</p>`, // Fallback to escaped text
      order: block.order,
    });
  }

  return result;
}

function escapeHtml(text: string): string {
  return text
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

/**
 * Extract all blocks for all pages from Rust tool's output directory
 */
export async function extractAllBlocksFromOutput(
  outputDir: string,
  pagesData: Array<{
    pageName: string;
    blocks: LogseqBlock[];
  }>
): Promise<Map<string, BlockHTML[]>> {
  const result = new Map<string, BlockHTML[]>();

  for (const pageData of pagesData) {
    const htmlPath = path.join(outputDir, `${pageData.pageName}.html`);

    try {
      const blockHTMLs = await extractBlocksFromHTML(htmlPath, pageData.blocks);
      result.set(pageData.pageName, blockHTMLs);
    } catch (error) {
      console.error(`Failed to extract blocks for ${pageData.pageName}:`, error);
      // Continue with other pages
    }
  }

  return result;
}
